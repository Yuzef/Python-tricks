# this is a file for tests

def yell(text):
    return text.upper() + '!'

bark = yell

print(bark('гав'))

# del yell  а доступ к функции через другое имя bark остался 

print(bark('гав'))


# functions can be added to a list
func = [bark, str.lower, str.capitalize]
print(func)
# access is the same
for f in func:
    print(f, f('всем привет'))

print(1,2,50,bark("efwef"))
# calling object-function without assigning a variable
print(func[0]('приветище'))

# function inside another function
# например, на результирующее приветствие можно влиять,
# передавая различные функции
def greet(func):
    greeting = func('Привет! Я - программа Python')
    print(greeting)

greet(bark)

def whisper(text):
    return text.lower() + '...'

greet(whisper)
# таким образом мы раздаем "поведение"
# Функции, которые в качестве аргументов
# могут принимать другие функции, называются
# Функциями более высокого порядка (higher-order function)
# Классический пример такой функции:
gr_list = list(map(bark,['эй', 'привет', 'здравствуй']))
print(gr_list)

# -------------------------------------------------------
#NESTED FUNCTIONS OR INNER FUNCTIONS - ВЛОЖЕННЫЕ ФУНКЦИИ

def speak(text):
    def whisper(t):
        return t.lower() + '...'
    return whisper(text)

print(speak('Привет, Мир'))

def get_speak_func(volume):
    def whisper(text):
        return text.lower() + '...'
    def yell(text):
        return text.upper() + '!'
    if  volume > 0.5:
        return yell
    else:
        return whisper

print(get_speak_func(0.3))
print(get_speak_func(0.7))

speak_func = get_speak_func(0.7)
print(speak_func('Привет'))

# c.72
# Таким образом функции могут возвращать линии поведения

# -------------------------------------------------------
# ВНУТРЕННИЕ ФУНКЦИИ МОГУТ
# ЗАХВАТЫВАТЬ И УНОСИТЬ С СОБОЙ ЧАСТЬ СОСТОЯНИЯ
# РОДИТЕЛЬСКОЙ ФУНКЦИИ

# перепишем код функции get_speak_func
# новая версия сразу принимает аргументы text и volume,
# чтобы немедленно сделать возвращаемую функцию вызываемой
# Также нет аргумента text во внутренних функциях
def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    if volume > 0.5:
        return yell
    else:
        return whisper
    
print(get_speak_func('Привет, Мир', 0.7)())
# Функции, которые таким образом помнят значения из своего
# контекста, называются лекс.ЗАМЫКАНИЯМИ (lexical closure)
# Значения запоминаются, даже когда поток управления
# программы больше не находится в этом контексте

# ПРАКТИЧЕСКИЙ СМЫСЛ
# Функции могут не только возвращать линии поведения,
# но и предварительно КОНФИГУРИРОВАТЬ эти линии поведения.

def make_adder(n):
    def add(x):
        return x + n
    return add

# make_adder служит ФАБРИКОЙ для создания и конфигурирования
# функций-сумматоров

plus_3 = make_adder(3)
plus_5 = make_adder(5)

print(plus_3(4))
print(plus_5(4))

# -------------------------------------------------------
# ОБЪЕКТЫ МОГУТ ВЕСТИ СЕБЯ КАК ФУНКЦИИ

# Не все объекты являются функциями, но они могут быть
# сделаны ВЫЗЫВАЕМЫМИ

# Если объект является вызываемым, то с ним можно
# использовать синтаксис функций

# Всё приводится в действие дандер-методом __call__

class Adder:
    def __init__(self, n): # теперь у объекта есть аттрибут
        self.n = n         # n = тому с чем его проинициализировали

    def __call__(self, x): # если вызовем объект как ф-цию,
        return self.n + x  # то исполн-ся этот метод

plus_4 = Adder(4)
print(plus_4(5))

# Произошел "вызов" экземпляра объекта в качестве ф-ции,
# что сводится к исполнению метода __call__ этого объекта.

# НЕ ВСЕ ОБЪЕКТЫ ЯВЛЯЮТСЯ ВЫЗЫВАЕМЫМИ
# Пр-ка через встроенную ф-цию callable

print(callable(plus_4))
print(callable(Adder(4)))
print(callable(yell))
print(callable('Привет'))

# -------------------------------------------------------
# с.75 ЛЯМБДЫ - Ф-ЦИИ ОДНОГО ВЫРАЖЕНИЯ
# (небольшие анонимные ф-ции через ключ. слово lambda)

# От обычной ф-ции ничем не отличаются - возвращают
# объект-функцию
add = lambda x, y: x + y
print(add(5, 3))

# функциональное выражение
print((lambda x, y: x + y)(5,3))
# не пришлось связывать объект-функцию с именем (анонимность)

# лямбды ограничены одним-единственным выражением - в лямбдах
# не могут применяться инструкции или аннотации
# return присутствует НЕЯВНО
# Лямбды также называют ФУНКЦИЯМИ ОДНОГО ВЫРАЖЕНИЯ

# ПРИМЕНЕНИЕ ЛЯМБД
# сортировка итерируемых объектов по альтернативному ключу
tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
print(sorted(tuples, key=lambda x: x[1]))
# лямбда-функция обеспечивает быстрый способ изменить
# порядок сортировки
print(sorted(range(-5,6), key=lambda x: x*x))

# как и обычные вложенные функции лямбды работают
# как ЛЕКСИЧЕСКИЕ ЗАМЫКАНИЯ
# ЛЕКСИЧЕСКИЕ ЗАМЫКАНИЯ - ф-ции, которые помнят значения
# из объемлющего лексического контекста, даже когда поток
# управления программы больше не находится в этом контексте
def make_adder(n):
    return lambda x: x + n

plus_3 = make_adder(3)
plus_5 = make_adder(5)
print(plus_3(4))
print(plus_5(4))

# -------------------------------------------------------
# ДЕКОРАТОРЫ
# позволяют изменять и расширять поведение вызываемых
# объектов БЕЗ необратимой модификации самих вызываемых
# объектов
# Универсальная функциональность - кандидат для декориро-
# вания:
# logging (журналирование)
# доступ и аутентификация - контроль
# ф-ции инструментального оформления и хронометража
# ограничение частоты вызова API
# кэширование (cashing)

# Декораторы "обертывают" ф-цию и позволяют исполнять
# программный код до и после того, как "обернутая" ф-ция
# выполнится.
# Декораторы определяют конструктивные блоки МНОГОКРАТНОГО
# использования (которые изменяют или расширяют поведение
# других ф-ций), НЕ ИЗМЕНЯЯ САМУ "ОБЕРНУТУЮ" Ф-ЦИЮ.
# Поведение изменяется только когда оно ДЕКОРИРОВАНО.
# Декоратор - вызываемый объект, который на входе принимает
# один вызываемый объект, а на выходе возвращает другой
# вызываемый объект.

# c.82
# САМЫЙ ПРОСТОЙ ДЕКОРАТОР (ф-ция имеет описанные выше св-ва)
def null_decorator(func):
    return func
# null_decorator - вызываемый объект (это ф-ция)
# на входе принимается ещё один вызываемый объект (func)
# на выходе возвращается вызываемый объект func

# Декорируем (обернём) ф-цию greet (вручную)
# ф-ция сначала опред-ся, а затем уже "прогоняется"
# через декоратор
def greet(): # определяется
    return 'Привет!'

greet = null_decorator(greet) # "прогоняется"
                              # (вызов декоратора ТУТ)
print(greet())

# Есть специальный синтаксис @ для декорирования ф-ций
@null_decorator
def greet():
    return 'Привет!'

print(greet())
# @ - декорирует ф-цию непосредственно во время её опред-я
# В результате становится трудно получить доступ к
# недекорированному оригиналу без хакерских фокусов.
# Следовательно, можно вручную (1-й вариант)
# декорировать некоторые ф-ции для сохранения
# способности вызывать и недекорированную ф-цию.

# Изменение поведения с помощью декораторов.

# Декоратор uppercase преобразовывает результат декор-й
# ф-ции в буквы верхнего регистра
def uppercase(func):
    def wrapper():
        original_result = func()
        modified_result = original_result.upper()
        return modified_result
    return wrapper
# "На лету" определили новую ф-цию wrapper - ЗАМЫКАНИЕ
# и используем её в качестве обертки, чтобы изменить
# поведение входной ф-ции ВО ВРЕМЯ ВЫЗОВА =>
# потребность в том, чтобы декоратор был в состоянии
# изменить поведение своей входной ф-ции, возникнет,
# только когда он наконец будет вызван.

# продекорируем оригинальную ф-цию greet
@uppercase
def greet():
    return 'Привет!'

print(greet())
# Декоратор uppercase сам является ф-цией.
# Единственный сп-б повлиять на "будущее поведение"
# входной ф-ции (которую он декорирует) - "обернуть"
# входную ф-цию ЗАМЫКАНИЕМ.
# Именно поэтому uppercase определяет и возвращает ещё
# одну ф-цию (замыкание) wrapper, которая выполняет
# оригинальную (входную) ф-цию и модифицирует её результат.

# Декораторы изменяют поведение посредством
# обертки-замыкания => не приходится необратимо
# модифицировать оригинал.

# Поведение объекта меняется, только когда он декорирован.

# Это позволяет прикреплять к существующим ф-циям и
# классам конструктивные блоки многократного использования
# (например для журналирования).

# ПРИМЕНЕНИЕ МНОГОЧИСЛЕННЫХ ДЕКОРАТОРОВ К Ф-ЦИИ.

# Их эффекты накапливаются
# Пример
# Обертывают выходную строку декорированной ф-ции в
# HTML-теги.
def strong(func):
    def wrapper():
        return '<strong>' + func() + '</strong>'
    return wrapper

def emphasis(func):
    def wrapper():
        return '<em>' + func() + '</em>'
    return wrapper
# одновременно применяем к ф-ции greet
@strong
@emphasis
def greet():
    return 'Привет!'

print(greet()) # <strong><em>Привет!</em></strong>
# Декораторы применяются СНИЗУ ВВЕРХ
# Сначала функция "обернулась" @emphasis, а потом уже
# "обернулась" декоратором @strong
# порядок - СТЕКОВАЯ УКЛАДКА ДЕКОРАТОРОВ

# Если избавиться от синтаксиса @, и написать вручную:
decorated_greet = strong(emphasis(greet))
# => Глубокие уровни укладки декораторов стековой укладки
# декораторов в конечном счете скажутся на
# производительности (из-за вызовов вложенных ф-ций).

# ДЕКОРИРОВАНИЕ Ф-ЦИЙ ПРИНИМАЮЩИХ АРГУМЕНТЫ (с.88)

# *args и **kwargs - функциональные ср-ва языка Python
# для работы с неизвестным кол-вом аргументов.
def proxy(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
# 1. Операторы * и ** собирают все позиционные и
#    именнованые аргументы, и помещают их в переменные
#    (args и kwargs).
# 2. Замыкание wrapper ПЕРЕАДРЕСУЕТ собраные аргументы в
#    оригинальную входную ф-цию func, используя "операто-
#    ры распаковки" * и **.

# Декоратор trace
# РЕГИСТРИРУЕТ аргументы ф-ции и итоговые результаты, по-
# лученные во время исполнения.
def trace(func):
    def wrapper(*args,**kwargs):
        print(f'ТРАССИРОВКА: вызвана {func.__name__}() '
              f'с {args}, {kwargs}')

        original_result = func(*args, **kwargs)

        print(f'ТРАССИРОВКА: {func.__name__}() '
              f'вернула {original_result!r}')
        return original_result
    return wrapper

@trace
def say(name, line):
    return f'{name}: {line}'

print(say('Юзеф', 1))

# КАК ПИСАТЬ "ОТЛАЖИВАЕМЫЕ" ДЕКОРАТОРЫ (С.89)

# Вследствии подмены одной ф-ции другой (декорироваания)
# скрываются мета-данные оригинальной (недокир-й) ф-ции.
# Скрыто замыканием-оберткой.
def greet():
    """Вернуть дружеское приветствие."""  # docstring
    return 'Привет!'

decorated_greet = uppercase(greet)  # Декорировалм вручную

print(greet.__name__)  # greet
print(greet.__doc__)  # Вернуть дружеское приветствие.

print(decorated_greet.__name__)  # wrapper
print(decorated_greet.__doc__)  # None

# Декоратор functools.wraps включённый в стандартную
# библиотеку Python.
# Можно исп-ть в своих декораторах для копирования поте-
# рянных метаданных из недекорированной ф-ции в замыкание
# декоратора.
import functools
def uppercase(func):
    @functools.wraps(func)
    def wrapper():
        return  func().upper()
    return wrapper
# Теперь строка документации и др-е метаданные перенесены
@uppercase
def greet():
    """Вернуть дружеское приветствие."""
    return 'Привет!'

print(greet.__doc__)
print(greet.__name__)

# ВЫВОД - ОПТИМАЛЬНЫЙ ПРАКТИЧЕСКИЙ ПРИЁМ:
# Использовать декоратор functools.wraps во всех своих
# декораторах.

# Декораторы не явл-ся панацеей и ими не стоит
# злоупотреблять. Нужно помнить о дальнейшем удобстве
# обслуживания кодовой базы.


#--------------------------------------------------------
# *args и **kwargs
# Позволяют принимать необязательные аргументы, благода-
# ря чему можно создавать гибкие API в модулях и классах.
def foo(required, *args, **kwargs):
    print(required)
    if args:
        print(args)
    if kwargs:
        print(kwargs)
# required - обязательный аргумент
# *args - доп-е позиционные аргументы собранные в кортеж
# **kwargs - доп-е именнованные аргументы собранные в
# словарь.
# >>> foo()
# TypeError:
#  "foo() missing 1 required positional arg: 'required'"
print(foo('Привет'))
print(foo('Привет', 1, 2, 3))
print(foo('Привет', 1, 2, 3, key1='значение', key2=999))
# Название параметров args и kwargs ПРИНЯТО ПО ДОГОВОРЕН-
# НОСТИ.
# Фактическим синтаксисом явл-ся * и **.

# ПЕРЕАДРЕСАЦИЯ НЕОБЯЗ-Х ИЛИ ИМЕННОВАННЫХ АРГУМЕНТОВ.
# Из одной ф-ции в другую при помощи операторов
# распаковки * и ** во время вызова ф-ции, в которую
# нужно переадресовать аргументы.
# Также их можно модифицировать перед передачей.
def foo(x, *args, **kwargs):
    kwargs['имя'] = 'Алиса'  # модифицируем
    new_args = args + ('дополнительный', )
    bar(x, *new_args, **kwargs)  # передаем
# Практически полезно для:
# 1) Создания производных классов;
# 2) Написания оберточных ф-ций.

# 1) Расширение поведения родительского класса без
# повторения полной сигнатуры его консструктора в дочер-
# нем классе.
# Удобно, если мы работаем с API, который может измен-ся
# за пределами наешго контроля.
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage

class AlwaysBlueCar(Car):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.color = 'синий'

print(AlwaysBlueCar('зеленый', 48392).color)  # синий
print(AlwaysBlueCar('зеленый', 48392).mileage)  # 48392
# Если конструктор родительского класса изм-ся, то
# велика вероятность, что AlwaysBlueCar будет по-прежнему
# функционировать как было задумано.
# (-) - конструктор AlwaysBlueCar имеет бесполезную сиг-
# натуру - не узнаем каки аргументы он ожидает, не
# заглянув в ролительский класс.

# 2) Написание оберточных ф-ций, таких как декораторы.
# Также принимаются произвольные арг-ты, которые пере-
# направляются в обернутую ф-цию.
# ВОЗМОЖНО благодаря отмены копипаста сигнатуры ориг-й
# ф-ции сопровождение станет удобнее - на обсуждение с
# коллегами.
def trace(f):
    @functools.wraps(f)
    def decorated_function(*args, **kwargs): # wrapper
        print(f, args, kwargs)
        result = f(*args, **kwargs)
        print(result)
    return decorated_function

@trace
def greet(greeting, name):
    return '{}, {}!'.format(greeting, name)

greet('Привет', 'Боб')

# РАСПАКОВКА АРГУМЕНТОВ Ф-ЦИИ из последовательностей и
# словарей при помощи операторов * и **.
def print_vector(x, y, z):
    print('<%s, %s, %s>' % (x, y, z))

print_vector(0, 1, 0)
# Векторы представленные в виде кортежей или списков
# передавать будет неудобно:
tuple_vect = (1, 0, 1)
list_vect = [1, 0, 1]
print_vector(tuple_vect[0],
             tuple_vect[1],
             tuple_vect[2])
# Это легче сделать при помощи РАСПАКОВКИ АРГ-В Ф-ЦИИ с
# c исп-м оператора * :
print_vector(*tuple_vect)
print_vector(*list_vect)
# Размещение * перед итерируемым объектом в вызове ф-ции
# его распакует и передаст его эл-ты как отдельные
# позиционные арг-ты в вызванную ф-цию.
# Этот приём работает для любого итерируемого объекта,
# включая выражения-генераторы.
# Все поступающие из генератора эл-ты будут исп-ны и
# переданы в ф-цию.
genexpr = (x * x for x in range(3))
print_vector(*genexpr)
# Аналогично исп-ся оператор ** для распаковки
# именованных арг-в, поступающих из словарей.
dict_vect = {'y' : 0, 'z' : 1, 'x' : 1}
print_vector(**dict_vect)
# Словари неупорядочены => оператор соотносит значения
# словаря и аргументы ф-ции на основе ключей словаря.
# Если для распаковки словаря исп-ть оператор *, то
# вместо этого ключи будут переданы в ф-цию в произвольн.
# порядке:
print_vector(*dict_vect)

# ЗДЕСЬ НЕЧЕГО ВОЗВРАЩАТЬ
# В конец ЛЮБОЙ ф-ции Python добавляет НЕЯВНУЮ инстр-ю
# return None.
# => Если не указано возращаемое значение, по умолч-ю
# вернётся None.
# => return None = Пустая инстр-я = пропущенная инстр-я
def foo1(value):
    if value:
        return value
    else:
        return None  #

def foo2(value):
    if value:
        return value
    else:
        return  # Пустая инсструкция

def foo3(value):
    if value:
        return value
        # Инстр-я пропущена, подразум-ся return None

# => ЭМПИРИЧЕСКОЕ ПРАВИЛО
# Если ф-ция не имеет возвращаемого значения (в др-х
# языках такая ф-ция назыв-ся ПРОЦЕДУРОЙ), то
# ИСКЛЮЧИТЬ ИНСТР-Ю return.

# ПРОГРАММНЫЙ КОД - ЭТО ОБЩЕНИЕ.


#--------------------------------------------------------\
# с.102 КЛАССЫ И ООП.













































