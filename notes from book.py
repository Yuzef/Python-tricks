# this is a file for tests
import json


def yell(text):
    return text.upper() + '!'

bark = yell

print(bark('гав'))

# del yell  а доступ к функции через другое имя bark остался 

print(bark('гав'))


# functions can be added to a list
func = [bark, str.lower, str.capitalize]
print(func)
# access is the same
for f in func:
    print(f, f('всем привет'))

print(1,2,50,bark("efwef"))
# calling object-function without assigning a variable
print(func[0]('приветище'))

# function inside another function
# например, на результирующее приветствие можно влиять,
# передавая различные функции
def greet(func):
    greeting = func('Привет! Я - программа Python')
    print(greeting)

greet(bark)

def whisper(text):
    return text.lower() + '...'

greet(whisper)
# таким образом мы раздаем "поведение"
# Функции, которые в качестве аргументов
# могут принимать другие функции, называются
# Функциями более высокого порядка (higher-order function)
# Классический пример такой функции:
gr_list = list(map(bark,['эй', 'привет', 'здравствуй']))
print(gr_list)

# -------------------------------------------------------
#NESTED FUNCTIONS OR INNER FUNCTIONS - ВЛОЖЕННЫЕ ФУНКЦИИ

def speak(text):
    def whisper(t):
        return t.lower() + '...'
    return whisper(text)

print(speak('Привет, Мир'))

def get_speak_func(volume):
    def whisper(text):
        return text.lower() + '...'
    def yell(text):
        return text.upper() + '!'
    if  volume > 0.5:
        return yell
    else:
        return whisper

print(get_speak_func(0.3))
print(get_speak_func(0.7))

speak_func = get_speak_func(0.7)
print(speak_func('Привет'))

# c.72
# Таким образом функции могут возвращать линии поведения

# -------------------------------------------------------
# ВНУТРЕННИЕ ФУНКЦИИ МОГУТ
# ЗАХВАТЫВАТЬ И УНОСИТЬ С СОБОЙ ЧАСТЬ СОСТОЯНИЯ
# РОДИТЕЛЬСКОЙ ФУНКЦИИ

# перепишем код функции get_speak_func
# новая версия сразу принимает аргументы text и volume,
# чтобы немедленно сделать возвращаемую функцию вызываемой
# Также нет аргумента text во внутренних функциях
def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    if volume > 0.5:
        return yell
    else:
        return whisper
    
print(get_speak_func('Привет, Мир', 0.7)())
# Функции, которые таким образом помнят значения из своего
# контекста, называются лекс.ЗАМЫКАНИЯМИ (lexical closure)
# Значения запоминаются, даже когда поток управления
# программы больше не находится в этом контексте

# ПРАКТИЧЕСКИЙ СМЫСЛ
# Функции могут не только возвращать линии поведения,
# но и предварительно КОНФИГУРИРОВАТЬ эти линии поведения.

def make_adder(n):
    def add(x):
        return x + n
    return add

# make_adder служит ФАБРИКОЙ для создания и конфигурирования
# функций-сумматоров

plus_3 = make_adder(3)
plus_5 = make_adder(5)

print(plus_3(4))
print(plus_5(4))

# -------------------------------------------------------
# ОБЪЕКТЫ МОГУТ ВЕСТИ СЕБЯ КАК ФУНКЦИИ

# Не все объекты являются функциями, но они могут быть
# сделаны ВЫЗЫВАЕМЫМИ

# Если объект является вызываемым, то с ним можно
# использовать синтаксис функций

# Всё приводится в действие дандер-методом __call__

class Adder:
    def __init__(self, n): # теперь у объекта есть аттрибут
        self.n = n         # n = тому с чем его проинициализировали

    def __call__(self, x): # если вызовем объект как ф-цию,
        return self.n + x  # то исполн-ся этот метод

plus_4 = Adder(4)
print(plus_4(5))

# Произошел "вызов" экземпляра объекта в качестве ф-ции,
# что сводится к исполнению метода __call__ этого объекта.

# НЕ ВСЕ ОБЪЕКТЫ ЯВЛЯЮТСЯ ВЫЗЫВАЕМЫМИ
# Пр-ка через встроенную ф-цию callable

print(callable(plus_4))
print(callable(Adder(4)))
print(callable(yell))
print(callable('Привет'))

# -------------------------------------------------------
# с.75 ЛЯМБДЫ - Ф-ЦИИ ОДНОГО ВЫРАЖЕНИЯ
# (небольшие анонимные ф-ции через ключ. слово lambda)

# От обычной ф-ции ничем не отличаются - возвращают
# объект-функцию
add = lambda x, y: x + y
print(add(5, 3))

# функциональное выражение
print((lambda x, y: x + y)(5,3))
# не пришлось связывать объект-функцию с именем (анонимность)

# лямбды ограничены одним-единственным выражением - в лямбдах
# не могут применяться инструкции или аннотации
# return присутствует НЕЯВНО
# Лямбды также называют ФУНКЦИЯМИ ОДНОГО ВЫРАЖЕНИЯ

# ПРИМЕНЕНИЕ ЛЯМБД
# сортировка итерируемых объектов по альтернативному ключу
tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
print(sorted(tuples, key=lambda x: x[1]))
# лямбда-функция обеспечивает быстрый способ изменить
# порядок сортировки
print(sorted(range(-5,6), key=lambda x: x*x))

# как и обычные вложенные функции лямбды работают
# как ЛЕКСИЧЕСКИЕ ЗАМЫКАНИЯ
# ЛЕКСИЧЕСКИЕ ЗАМЫКАНИЯ - ф-ции, которые помнят значения
# из объемлющего лексического контекста, даже когда поток
# управления программы больше не находится в этом контексте
def make_adder(n):
    return lambda x: x + n

plus_3 = make_adder(3)
plus_5 = make_adder(5)
print(plus_3(4))
print(plus_5(4))

# -------------------------------------------------------
# ДЕКОРАТОРЫ
# позволяют изменять и расширять поведение вызываемых
# объектов БЕЗ необратимой модификации самих вызываемых
# объектов
# Универсальная функциональность - кандидат для декориро-
# вания:
# logging (журналирование)
# доступ и аутентификация - контроль
# ф-ции инструментального оформления и хронометража
# ограничение частоты вызова API
# кэширование (cashing)

# Декораторы "обертывают" ф-цию и позволяют исполнять
# программный код до и после того, как "обернутая" ф-ция
# выполнится.
# Декораторы определяют конструктивные блоки МНОГОКРАТНОГО
# использования (которые изменяют или расширяют поведение
# других ф-ций), НЕ ИЗМЕНЯЯ САМУ "ОБЕРНУТУЮ" Ф-ЦИЮ.
# Поведение изменяется только когда оно ДЕКОРИРОВАНО.
# Декоратор - вызываемый объект, который на входе принимает
# один вызываемый объект, а на выходе возвращает другой
# вызываемый объект.

# c.82
# САМЫЙ ПРОСТОЙ ДЕКОРАТОР (ф-ция имеет описанные выше св-ва)
def null_decorator(func):
    return func
# null_decorator - вызываемый объект (это ф-ция)
# на входе принимается ещё один вызываемый объект (func)
# на выходе возвращается вызываемый объект func

# Декорируем (обернём) ф-цию greet (вручную)
# ф-ция сначала опред-ся, а затем уже "прогоняется"
# через декоратор
def greet(): # определяется
    return 'Привет!'

greet = null_decorator(greet) # "прогоняется"
                              # (вызов декоратора ТУТ)
print(greet())

# Есть специальный синтаксис @ для декорирования ф-ций
@null_decorator
def greet():
    return 'Привет!'

print(greet())
# @ - декорирует ф-цию непосредственно во время её опред-я
# В результате становится трудно получить доступ к
# недекорированному оригиналу без хакерских фокусов.
# Следовательно, можно вручную (1-й вариант)
# декорировать некоторые ф-ции для сохранения
# способности вызывать и недекорированную ф-цию.

# Изменение поведения с помощью декораторов.

# Декоратор uppercase преобразовывает результат декор-й
# ф-ции в буквы верхнего регистра
def uppercase(func):
    def wrapper():
        original_result = func()
        modified_result = original_result.upper()
        return modified_result
    return wrapper
# "На лету" определили новую ф-цию wrapper - ЗАМЫКАНИЕ
# и используем её в качестве обертки, чтобы изменить
# поведение входной ф-ции ВО ВРЕМЯ ВЫЗОВА =>
# потребность в том, чтобы декоратор был в состоянии
# изменить поведение своей входной ф-ции, возникнет,
# только когда он наконец будет вызван.

# продекорируем оригинальную ф-цию greet
@uppercase
def greet():
    return 'Привет!'

print(greet())
# Декоратор uppercase сам является ф-цией.
# Единственный сп-б повлиять на "будущее поведение"
# входной ф-ции (которую он декорирует) - "обернуть"
# входную ф-цию ЗАМЫКАНИЕМ.
# Именно поэтому uppercase определяет и возвращает ещё
# одну ф-цию (замыкание) wrapper, которая выполняет
# оригинальную (входную) ф-цию и модифицирует её результат.

# Декораторы изменяют поведение посредством
# обертки-замыкания => не приходится необратимо
# модифицировать оригинал.

# Поведение объекта меняется, только когда он декорирован.

# Это позволяет прикреплять к существующим ф-циям и
# классам конструктивные блоки многократного использования
# (например для журналирования).

# ПРИМЕНЕНИЕ МНОГОЧИСЛЕННЫХ ДЕКОРАТОРОВ К Ф-ЦИИ.

# Их эффекты накапливаются
# Пример
# Обертывают выходную строку декорированной ф-ции в
# HTML-теги.
def strong(func):
    def wrapper():
        return '<strong>' + func() + '</strong>'
    return wrapper

def emphasis(func):
    def wrapper():
        return '<em>' + func() + '</em>'
    return wrapper
# одновременно применяем к ф-ции greet
@strong
@emphasis
def greet():
    return 'Привет!'

print(greet()) # <strong><em>Привет!</em></strong>
# Декораторы применяются СНИЗУ ВВЕРХ
# Сначала функция "обернулась" @emphasis, а потом уже
# "обернулась" декоратором @strong
# порядок - СТЕКОВАЯ УКЛАДКА ДЕКОРАТОРОВ

# Если избавиться от синтаксиса @, и написать вручную:
decorated_greet = strong(emphasis(greet))
# => Глубокие уровни укладки декораторов стековой укладки
# декораторов в конечном счете скажутся на
# производительности (из-за вызовов вложенных ф-ций).

# ДЕКОРИРОВАНИЕ Ф-ЦИЙ ПРИНИМАЮЩИХ АРГУМЕНТЫ (с.88)

# *args и **kwargs - функциональные ср-ва языка Python
# для работы с неизвестным кол-вом аргументов.
def proxy(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
# 1. Операторы * и ** собирают все позиционные и
#    именнованые аргументы, и помещают их в переменные
#    (args и kwargs).
# 2. Замыкание wrapper ПЕРЕАДРЕСУЕТ собраные аргументы в
#    оригинальную входную ф-цию func, используя "операто-
#    ры распаковки" * и **.

# Декоратор trace
# РЕГИСТРИРУЕТ аргументы ф-ции и итоговые результаты, по-
# лученные во время исполнения.
def trace(func):
    def wrapper(*args,**kwargs):
        print(f'ТРАССИРОВКА: вызвана {func.__name__}() '
              f'с {args}, {kwargs}')

        original_result = func(*args, **kwargs)

        print(f'ТРАССИРОВКА: {func.__name__}() '
              f'вернула {original_result!r}')
        return original_result
    return wrapper

@trace
def say(name, line):
    return f'{name}: {line}'

print(say('Юзеф', 1))

# КАК ПИСАТЬ "ОТЛАЖИВАЕМЫЕ" ДЕКОРАТОРЫ (С.89)

# Вследствии подмены одной ф-ции другой (декорироваания)
# скрываются мета-данные оригинальной (недокир-й) ф-ции.
# Скрыто замыканием-оберткой.
def greet():
    """Вернуть дружеское приветствие."""  # docstring
    return 'Привет!'

decorated_greet = uppercase(greet)  # Декорировалм вручную

print(greet.__name__)  # greet
print(greet.__doc__)  # Вернуть дружеское приветствие.

print(decorated_greet.__name__)  # wrapper
print(decorated_greet.__doc__)  # None

# Декоратор functools.wraps включённый в стандартную
# библиотеку Python.
# Можно исп-ть в своих декораторах для копирования поте-
# рянных метаданных из недекорированной ф-ции в замыкание
# декоратора.
import functools
def uppercase(func):
    @functools.wraps(func)
    def wrapper():
        return  func().upper()
    return wrapper
# Теперь строка документации и др-е метаданные перенесены
@uppercase
def greet():
    """Вернуть дружеское приветствие."""
    return 'Привет!'

print(greet.__doc__)
print(greet.__name__)

# ВЫВОД - ОПТИМАЛЬНЫЙ ПРАКТИЧЕСКИЙ ПРИЁМ:
# Использовать декоратор functools.wraps во всех своих
# декораторах.

# Декораторы не явл-ся панацеей и ими не стоит
# злоупотреблять. Нужно помнить о дальнейшем удобстве
# обслуживания кодовой базы.


#--------------------------------------------------------
# *args и **kwargs
# Позволяют принимать необязательные аргументы, благода-
# ря чему можно создавать гибкие API в модулях и классах.
def foo(required, *args, **kwargs):
    print(required)
    if args:
        print(args)
    if kwargs:
        print(kwargs)
# required - обязательный аргумент
# *args - доп-е позиционные аргументы собранные в кортеж
# **kwargs - доп-е именнованные аргументы собранные в
# словарь.
# >>> foo()
# TypeError:
#  "foo() missing 1 required positional arg: 'required'"
print(foo('Привет'))
print(foo('Привет', 1, 2, 3))
print(foo('Привет', 1, 2, 3, key1='значение', key2=999))
# Название параметров args и kwargs ПРИНЯТО ПО ДОГОВОРЕН-
# НОСТИ.
# Фактическим синтаксисом явл-ся * и **.

# ПЕРЕАДРЕСАЦИЯ НЕОБЯЗ-Х ИЛИ ИМЕННОВАННЫХ АРГУМЕНТОВ.
# Из одной ф-ции в другую при помощи операторов
# распаковки * и ** во время вызова ф-ции, в которую
# нужно переадресовать аргументы.
# Также их можно модифицировать перед передачей.
def foo(x, *args, **kwargs):
    kwargs['имя'] = 'Алиса'  # модифицируем
    new_args = args + ('дополнительный', )
    bar(x, *new_args, **kwargs)  # передаем
# Практически полезно для:
# 1) Создания производных классов;
# 2) Написания оберточных ф-ций.

# 1) Расширение поведения родительского класса без
# повторения полной сигнатуры его консструктора в дочер-
# нем классе.
# Удобно, если мы работаем с API, который может измен-ся
# за пределами наешго контроля.
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage

class AlwaysBlueCar(Car):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.color = 'синий'

print(AlwaysBlueCar('зеленый', 48392).color)  # синий
print(AlwaysBlueCar('зеленый', 48392).mileage)  # 48392
# Если конструктор родительского класса изм-ся, то
# велика вероятность, что AlwaysBlueCar будет по-прежнему
# функционировать как было задумано.
# (-) - конструктор AlwaysBlueCar имеет бесполезную сиг-
# натуру - не узнаем каки аргументы он ожидает, не
# заглянув в ролительский класс.

# 2) Написание оберточных ф-ций, таких как декораторы.
# Также принимаются произвольные арг-ты, которые пере-
# направляются в обернутую ф-цию.
# ВОЗМОЖНО благодаря отмены копипаста сигнатуры ориг-й
# ф-ции сопровождение станет удобнее - на обсуждение с
# коллегами.
def trace(f):
    @functools.wraps(f)
    def decorated_function(*args, **kwargs): # wrapper
        print(f, args, kwargs)
        result = f(*args, **kwargs)
        print(result)
    return decorated_function

@trace
def greet(greeting, name):
    return '{}, {}!'.format(greeting, name)

greet('Привет', 'Боб')

# РАСПАКОВКА АРГУМЕНТОВ Ф-ЦИИ из последовательностей и
# словарей при помощи операторов * и **.
def print_vector(x, y, z):
    print('<%s, %s, %s>' % (x, y, z))

print_vector(0, 1, 0)
# Векторы представленные в виде кортежей или списков
# передавать будет неудобно:
tuple_vect = (1, 0, 1)
list_vect = [1, 0, 1]
print_vector(tuple_vect[0],
             tuple_vect[1],
             tuple_vect[2])
# Это легче сделать при помощи РАСПАКОВКИ АРГ-В Ф-ЦИИ с
# c исп-м оператора * :
print_vector(*tuple_vect)
print_vector(*list_vect)
# Размещение * перед итерируемым объектом в вызове ф-ции
# его распакует и передаст его эл-ты как отдельные
# позиционные арг-ты в вызванную ф-цию.
# Этот приём работает для любого итерируемого объекта,
# включая выражения-генераторы.
# Все поступающие из генератора эл-ты будут исп-ны и
# переданы в ф-цию.
genexpr = (x * x for x in range(3))
print_vector(*genexpr)
# Аналогично исп-ся оператор ** для распаковки
# именованных арг-в, поступающих из словарей.
dict_vect = {'y' : 0, 'z' : 1, 'x' : 1}
print_vector(**dict_vect)
# Словари неупорядочены => оператор соотносит значения
# словаря и аргументы ф-ции на основе ключей словаря.
# Если для распаковки словаря исп-ть оператор *, то
# вместо этого ключи будут переданы в ф-цию в произвольн.
# порядке:
print_vector(*dict_vect)

# ЗДЕСЬ НЕЧЕГО ВОЗВРАЩАТЬ
# В конец ЛЮБОЙ ф-ции Python добавляет НЕЯВНУЮ инстр-ю
# return None.
# => Если не указано возращаемое значение, по умолч-ю
# вернётся None.
# => return None = Пустая инстр-я = пропущенная инстр-я
def foo1(value):
    if value:
        return value
    else:
        return None  #

def foo2(value):
    if value:
        return value
    else:
        return  # Пустая инсструкция

def foo3(value):
    if value:
        return value
        # Инстр-я пропущена, подразум-ся return None

# => ЭМПИРИЧЕСКОЕ ПРАВИЛО
# Если ф-ция не имеет возвращаемого значения (в др-х
# языках такая ф-ция назыв-ся ПРОЦЕДУРОЙ), то
# ИСКЛЮЧИТЬ ИНСТР-Ю return.

# ПРОГРАММНЫЙ КОД - ЭТО ОБЩЕНИЕ.


#--------------------------------------------------------
# с.102 КЛАССЫ И ООП.

# 4.1 СРАВНЕНИЯ ОБЪЕКТОВ: is против ==.
# == это равенство ("внешне" одинаковые объекты-близнецы)
# is это тождество (именно этот объект в памяти)
a = [1, 2, 3]
b = a
print(a == b)  # True
# УКАЗЫВАЮТ ли на один и тот же объект? => is
print(a is b)  # True
# А теперь сделаем ИДЕНТИЧНУЮ КОПИЮ с помощью list()
c = list(a)  # [1, 2, 3]
print(c == a)  # True ("внешне" одинаковы)
print(c is a)  # False (но это разные объекты,
               # и ссылки на них разные)

# 4.2 ПРЕОБРАЗОВАНИЕ СТРОК.
# При определ-и своего класса и его печати получается
# некрасивый вывод.
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage

my_car = Car('Красный', 37281)
print(my_car)
# По умолчанию - имя класса и идентификатор экземпляра
# объекта (адрес объекта в оперативной памяти).

# НУЖНО ДОБАВИТЬ ДАНДЕР-МЕТОДЫ __str__ и __repr__
# Они представляют собой питоновский способ управл-я
# преобразованием объектов в строковые значения в разл.
# ситуациях.

# Добавим метод __str__ в класс Car
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __str__(self):
        return f'{self.color} автомобиль'

my_car = Car('красный', 37281)
print(my_car)
# Это питоновский сп-б управлять преобразованием строк.
# В Java например, надо переписать метод to_string().

# Инспектирование в консоли по-прежнему даст предыдущий
# результат, содержащий идентификатор объекта.

# МЕТОД __str__ против __repr__
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __repr__(self):
        return '__repr__ для объекта Car'
    def __str__(self):
        return '__str__ для объекта Car'
# Какой метод управляет результ-м преобразования строк
# в каждом сл-е:
my_car = Car('красный', 37281)
print(my_car)  # __str__ для объекта Car
print('{}'.format(my_car))  # __str__ для объекта Car
print(repr(my_car))  # __repr__ для объекта Car
# Также если в консоли вызвать объект, то будет то что
# в __repr__

# В контейнерах (списки, словари) исп-ся результат
# метода __repr__, даже если вызвать ф-цию str() с
# самим контейнером
print(str([my_car]))  # [__repr__ для объекта Car]

# Разница между __str__ и __repr__
import datetime
today = datetime.date.today()
# Резултат __str__ должен быть УДОБОЧИТАЕМЫМ
# Результат __repr__ должен быть ОДНОЗНАЧНЫМ и ПОЛЕЗНЫМ
# ДЛЯ РАЗРАБОТЧИКОВ (как средство отладки).
print(str(today))  # 2022-06-17
print(repr(today))  # datetime.date(2022, 6, 17)

# КАЖДЫЙ КЛАСС НУЖДАЕТСЯ __repr__
# Если опусстить метод __str__ , то Python отыграет на-
# зад к методу __repr__
# => Нужно добавлять в свои классы хотя бы __repr__
# (самая элементарная поддержка преобразования строк).
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __repr__(self):
        # return f'Car({self.color!r}, {self.mileage!r})'
        # !s chooses to use str()
        # !r chooses to use repr()
        # Explicit is better than implicit, so
        # it's better to use {repr(self.color)}
        # instead of {self.color!r}
        return f'Car({repr(self.color)},' \
               f'{repr(self.mileage)})'

my_car = Car('красный', 377370)
print(my_car)
# Чтобы не повторять имя класса в форматной строке
# можно применить трюк с исп-м атрибута
# __class__.__name__ объекта.
# Будет отображено имя класса в виде строки.
# => Не прийдется модифицировать метод __repr__ , если
# изменится имя класса.
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'{self.color!r}, {self.mileage!r})')

my_car = Car('синий', 377371)
print(my_car)

# ОПРЕД-Е СВОИХ СОБСТВЕННЫХ КЛАССОВ-ИСКЛЮЧЕНИЙ.
# Опред-е своих собственных типов ошибок может быть очень
# ценным.

# 1) Валидация входного строкового значения.
def validate(name):
    if len(name) < 10:
        raise ValueError
# Использование универсального класса-исключения
# "высокого уровня" типа ValueError приводит к слишком
# абстрактному сообщению об исключении.
# => Введём собственный тип исключений
# => Потсроим наш класс-исключение на основе ValueError,
# дадим ему более конкретное имя.
class NameTooShortError(ValueError):
    pass
def validate(name):
    if len(name) < 10:
        raise NameTooShortError(name)
# Наш новый тип искл-й NameTooShortError явл-ся "само-
# документирующим" (всё понятно из названия)

# При выпуске пакета в публичное пространство или модуля
# многократного использования ОБРАЗЦОВАЯ ПРАКТИКА
# предусматривает создание для такого модуля собств.
# базового класса-исключения и создание производных от
# него всех других собственных исключений.
# 1. Создание базового класса:
class BaseValidationError(ValueError):
    pass
# 2. Создание производных от базового класса ошибок:
class NameTooShortError(BaseValidationError):
    pass

class NameTooLongError(BaseValidationError):
    pass

class NameTooCuteError(BaseValidationError):
    pass

# => Это позволяет пользователям ЭТОГО ПАКЕТА,
# отлавливать ошибки ЭТОГО ПАКЕТА, с помощью инструкций
# try-except, не захватывая все исключения с помощью
# всеобъемлющего except.

# try:
#     validate(name)
# except BaseValidationError as err:
#     handle_validation_error(err)
# НО С ЭТИМ АККУРАТНО И ПО ДОГОВОРЕННОСТИ С КОЛЛЕГАМИ.

# 4.4 КЛОНИРОВАНИЕ ОБЪЕКТОВ. c. 118
# Инструкции присваивания не создают копии, они лишь при-
# вязывают имена к объекту.

# Копирование встроенных в Python коллекций (списки,
# словари, множества) :
# создание МЕЛКОЙ КОПИИ / SHALLOW COPY -
# конструирование НОВОГО объекта коллекции, затем запол-
# нение его ссылками на дочерние объекты, найденные в
# оригинале.
# => мелкая копия имеет всего один уровень в глубину,
# процесс копирования нерекурсивный => нет копий самих
# дочерних объектов.
original_list = [1, 2, 3, 7]
original_dict = {'Мама': 1, 'Брат': 2}
original_set = {'Кот', 'Собака'}
new_list = list(original_list)
new_dict = list(original_dict)
new_set = list(original_set)
# ГЛУБОКАЯ КОПИЯ / DEEP COPY -
# выполн-ся процесс уопирования РЕКУРСИВНО.
# Конструирование нового объекта коллекции -> рекурсивное
# заполнение копиями дочерних объектов, найденных в ориг.
# => выполн-ся обход всего дерева объектов целиком,
# создается ПОЛНОСТЬЮ НЕЗАВИСИМЫЙ КЛОН исходного объекта
# и его потомков.

# СОЗДАНИЕ МЕЛКИХ КОПИЙ.
xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
ys = list(xs)  # Созданием мелкой копии
# ys теперь новый независимый объект
print(xs)
print(ys)
# Добавим подсписок в оригинал xs и убедимся, что это не
# затронуло мелкую копию ys.
xs.append(['новый подсписок'])
print(xs)
print(ys)
# => с изменением на "поверхностом" уровне проблем не
# возникло,
# однако список ys по-прежнему содержит ссылки на ориг-е
# дочерние объекты, хранящиеся в xs
# => Эти дочерние эл-ты не были скопированы,
# => В скопированом списке на них содержаться ссылки.
# При модификации объекта в оригинале xs это отобразится
# на ys.
# ОБА СПИСКА СОВМЕСТНО ИСПОЛЬЗУЮТ ОДИНАКОВЫЕ ДОЧЕРНИЕ
# ОБЪЕКТЫ.
xs[1][0] = 'X'
print(xs)  # [[1, 2, 3], ['X', 5, 6], [7, 8, 9], ['новый подсписок']]
print(ys)  # [[1, 2, 3], ['X', 5, 6], [7, 8, 9]]
# Если бы мы создали ГЛУБОКУЮ КОПИЮ, то этого бы не
# произошло, оба объекта были бы полн-ю независимыми.

# СОЗДАНИЕ ГЛУБОКИХ КОПИЙ.
import copy
xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
zs = copy.deepcopy(xs)
print(xs)
print(zs)
# Список xs был КЛОНИРОВАН рекурсивно, включая все его
# дочерние объекты.
xs[1][0] = 'X'
print(xs)  # [[1, 2, 3], ['X', 5, 6], [7, 8, 9]]
print(zs)  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# Ф-ция copy.copy() создаем мелкие копии объектов.

# КОПИРОВАНИЕ ПРОИЗВОЛЬНЫХ ОБЪЕКТОВ.
# Как создавать копии (мелкие и глубокие) произвольных
# объектов, включая собственные классы.
# copy.copy() и copy.deepcopy() могут исп-ся для создания
# дубликата любого объекта.
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Point({self.x!r}, {self.y!r})'

a = Point(23, 42)
b = copy.copy(a)
print(a)  # Point(23, 42)
print(b)  # Point(23, 42)
print(a is b)  # False
# Поскольку наш объект использует примитивные типы (целые
# числа), то нет никакой разницы между глубокой и мелкой
# копией.

# класс двумерных прямоугольников
# прямоугольники исп-т объекты Point, представл-е их
# координаты.
class Rectangle:
    def __init__(self, topleft, bottomright):
        self.topleft = topleft
        self.bottomright = bottomright

    def __repr__(self):
        return (f'Rectangle({self.topleft!r},'\
               f'{self.bottomright!r})')

# мелкая копия экземпляра Rectangle
rect = Rectangle(Point(0, 1), Point(5, 6))
srect = copy.copy(rect)
print(rect)  # Rectangle(Point(0, 1),Point(5, 6))
print(srect)  # Rectangle(Point(0, 1),Point(5, 6))
print(rect is srect)  # False

rect.topleft.x = 999
print(rect)  # Rectangle(Point(999, 1),Point(5, 6))
print(srect)  # Rectangle(Point(999, 1),Point(5, 6))

# Creating deep copy
drect = copy.deepcopy(srect)
drect.topleft.x = 222
print(drect)  # Rectangle(Point(222, 1),Point(5, 6))
print(srect)  # Rectangle(Point(999, 1),Point(5, 6))

# 4.5 АБСТРАКТНЫЕ БАЗОВЫЕ КЛАССЫ ДЕРЖАТ НАСЛЕДОВАНИЕ ПОД
#     КОНТРОЛЕМ. (АБСТРАКТНЫЕ БАЗОЫЕ КЛАССЫ)

# - СОЗДАНИЕ ЭКЗЕМПЛЯРОВ БАЗОВОГО (АБСТРАКТНОГО) КЛАССА
#   НЕВОЗМОЖНО.
# - В ПОДКЛАССЕ ОБЯЗАТЕЛЬНО НАДО РЕАЛИЗОВЫВАТЬ МЕТОДЫ
#   ИНТЕРФЕСА ИЗ АБСТРАКТНОГО КЛАССА.

# Чтоюы обеспечить реализацию методов базового класса
# производным классом, как правило, используется идиома:
from abc import ABCMeta, abstractmethod

class Base(metaclass=ABCMeta):
    @abstractmethod
    def foo(self):
        pass

    @abstractmethod
    def bar(self):
        pass

class Concrete(Base):
    def foo(self):
        pass

    def bar(self):
        pass

# Подклассы Base вызывают искл-е TypeError ВО ВРЕМЯ
# СОЗДАНИЯ ЭКЗЕМПЛЯРА всякий раз, когда мы забываем
# реализовать какие-либо абстрактные методы.
# Вызванное искл-е будет говорить о том какой метод или
# методы отсутствуют.
# => В результате написание недопустимых подклассов в
# значительной степени блокируется.

# 4.6 ЧЕМ ПОЛЕЗНЫ ИМЕНОВАННЫЕ КОРТЕЖИ.
# namedtuple - специализированный контейнерный тип,
#              именованный кортеж.
# namedtuple - расширение встроенного типа данных tuple.
# Кортежи (tuple) - простая структура данных, предназн-я
# для группирования ПРОИЗВОЛЬНЫХ ОБЪЕКТОВ.
# Кортежи не могут ИЗМЕНЯТЬСЯ.
tup = ('привет', object(), 42)
print(tup)
print(tup[2])
# tup[2] = 23
# TypeError:
# "'tuple' object does not support item assignment"

# (-) - хранящиеся данные могут быть извлечены только
#       адресацией посредством целочисленных индексов.
# => нельзя назначать имена отдельным св-вам, хранящимся
# в кортеже => это может быть неудобочитаемо.

# Именованные кортежи (namedtuple) - явл-ся НЕИЗМЕНЯЕМЫМИ
#                    КОНТЕЙНЕРАМИ, КАК И ОБЫЧНЫЕ КОРТЕЖИ.
# => «Однократная запись, многократное чтение».
# Доступ к каждому хранящемуся объекту можно получить
# через уникальный (человекочитаемый) идентификатор.
from collections import namedtuple
Car = namedtuple('Авто', 'цвет пробег')
# Первый аргумент - имя типа (имя нового класса), это
# имя потом будет исп-ся в строке документации docstring
# и в реализации метода __repr__ , которые ф-ция
# namedtuple() генерирует автоматически.
# Поля передаются в виде строки или списка.
# Строка => будет неявно вызван метод split() со строкой
# содержащей имена полей => она преобразуется в список
# имен полей: 'цвет пробег'.split() -> ['цвет', 'пробег']

# Теперь при помощи фабричной ф-ции Car можно создавать
# новые объекты.
# Поведение точно такое же как если создать класс Car
# вручную и опр-ть в нём конструктор, принимающий знач-я
# "цвет", "пробег" :
my_car = Car("красный", 3812.4)
print(my_car.цвет)  # красный
print(my_car.пробег)  # 3812.4
# Также можно получать доступ по индексу:
print(my_car[0])  # красный
# => Именованные кортежи могут исп-ся в кач-ве прямой
# замены обычным кортежам.
print(my_car)  # Авто(цвет='красный', пробег=3812.4)
print(tuple(my_car))  # ('красный', 3812.4)
# Распаковка и оператор * работают правильно
color, mileage = my_car
print(color, mileage)  # красный 3812.4
print(*my_car)  # красный 3812.4
print(*tuple(my_car))  # красный 3812.4

# Если попытаться переписать одно из полей => вылезет
# AttributeError
# На внутреннем ур-не объекты namedtuple реализованы как
# обычные классы Python.
# Используют оперативную память лучше, по потреблению
# также как и обычные кортежи.
# Именованные кортежи стоит рассматривать как ЭФФЕКТИВНУЮ
# С ТОЧКИ ЗРЕНИЯ ПОТРЕБЛЕНИЯ ОПЕРАТИВНОЙ ПАМЯТИ КРАТКУЮ
# ФОРМУ ДЛЯ ОПРЕД-Я НЕИЗМЕНЯЮЩЕГОСЯ КЛАССА ВРУЧНУЮ.

# СОЗДАНИЕ ПРОИЗВОДНЫХ ОТ Namedtuple ПОДКЛАССОВ.
# Т.к. объекты namedtuple строятся поверх обычных классов,
# => в них можно добавлять свои методы.
# Пример: расширим класс namedtuple -> добавим в него ме-
# тоды и новые св-ва:
Car = namedtuple('Авто', 'цвет пробег')
class MyCarWithMethods(Car):
    def hexcolor(self):
        if self.цвет == 'красный':
            return '#ff0000'
        else:
            return '#000000'

c = MyCarWithMethods('красный', 1234)
print(c.hexcolor())  # #ff0000
# НО У ТАКИХ КЛАССОВ являющихся подклассами от namedtuple
# есть своя сложность В ДОБАВЛЕНИИ НОВОГО НЕИЗМЕНЯЕМОГО
# ПОЛЯ (immutable field) из-за внутренней структуры
# именованных кортежей.

# САМЫЙ ЛЕГКИЙ СП-Б СОЗДАТЬ ИЕРАРХИИ ИМЕНОВ-Х КОРТЕЖЕЙ -
# исп-ть св-ва _fields базового кортежа:
Car = namedtuple('Авто', 'цвет пробег')
ElectricCar = namedtuple('ЭлектричекоеАвто', Car._fields
                         + ('заряд',))
print(ElectricCar('красный', 1234, 45.0))  # ЭлектричекоеАвто(цвет='красный', пробег=1234, заряд=45.0)

# ВСТРОЕННЫЕ ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ.
# Существует несколько приватных методов (начинаются с _)
# у экземпляров именованных кортежей.
# У класса namedtuple такие методы (начинающиеся с _)
# явл-ся составной частью публичного интрерфейса.
# _ - для избежания конфликта имен с определяемыми
# пользователем полями кортежей.

# _asdict()
print(my_car._asdict())  # {'цвет': 'красный', 'пробег': 3812.4}
# Для избежания опечаток в названиях полей, например во
# время генерирования рез-та в формате JSON:
print(json.dumps(my_car._asdict(), ensure_ascii=False))
# False для кириллицы
# {"цвет": "красный", "пробег": 3812.4}

# _replace() - создает мелкую копию кортежа, позволяет
# выборочно заменять некоторые поля.
print(my_car._replace(цвет='синий'))  # shallow copy
print(my_car)  # оригинал остался неизмененным

# _make - исп-ся для создания новых экземпляров класса
# namedtuple из (итерируемой) последовательности:
print(Car._make(['красный', 999]))
# Авто(цвет='красный', пробег=999)

# 4.7 ПЕРЕМЕННЫЕ КЛАССА ПРОТИВ ПЕРЕМЕННЫХ ЭКЗЕМПЛЯРА:
#     ПОДВОДНЫЕ КАМНИ.

# Переменные класса (class variables)
# Переменные экземпляра (instance variables)
class Dog:
    num_legs = 4  # Переменная класса

    def __init__(self, name):
        self.name = name  # Переменная экземпляра

jack = Dog('Джек')
jill = Dog('Джилл')
print(jack.name, jill.name)  # Джек Джилл
# Во всём, что касается переменных класса, всегда есть
# чуть больше гибкости:
# доступ к переменной класса (class variable) можно
# получить через каждый экземпляр, либо через сам класс.
print(jack.num_legs, jill.num_legs)  # 4 4
print(Dog.num_legs)  # 4
# Попытка получить доступ к переменной экземпляра через
# класс потерпит неудачу с исключением AttributeError.
# >>> Dog.name
# AttributeError:
# "type object 'Dog' has no attribute 'name'"

# Модификация переменной КЛАССА в прсотранстве имен
# класса затрагивает ВСЕ ЭКЗЕМПЛЯРЫ КЛАССА:
Dog.num_legs = 6  # Теперь у всех собак 6 лап
print(jack.num_legs, jill.num_legs)  # 6 6
Dog.num_legs = 4  # вернули обратно
jack.num_legs = 6  # Изменили только у одной собаки
print(jack.num_legs, jill.num_legs, Dog.num_legs)
# 6 4 4
# Теперь новая переменная экземпляра num_legs
# «оттеняет» переменную класса с тем же самым именем,
# ПЕРЕОПРЕДЕЛЯЯ и СКРЫВАЯ ее, когда мы обращаемся к
# области действия экземпляра:
print(jack.num_legs)  # новая переменная экземпляра
print(jack.__class__.num_legs)  # старая перем-я класса
# 6 4
# => внесение изменений в jack.num_legs СОЗДАЛО перем-ю
# ЭКЗЕМПЛЯРА с ТЕМ ЖЕ САМЫМ ИМЕНЕМ, что и у переменной
# класса.

# БОЛЕЕ РЕАЛЬНЫЙ ПРИМЕР:
# Класс CountedObject отслеживает, сколько раз он
# использовался для создания экземпляров на протяжении
# жизни программы (метрический показатель производи-
# тельности).
class CountedObject:
    num_instances = 0  # Общий счетчик

    def __init__(self):
        self.__class__.num_instances += 1

# 4.8 МЕТОДЫ ЭКЗЕМПЛЯРА, КЛАССА И СТАТИЧЕСКИЕ МЕТОДЫ.
#     Instance method, class method & static method.

class MyClass:
    def method(self):
        return 'вызван метод экземпляра', self

    @classmethod
    def classmethod(cls):
        return 'вызван метод класса', cls

    @staticmethod
    def staticmethod():
        return 'вызван статический метод'
# Методы класса - Class methods
# Параметр cls указывает на класс во время вызова метода
# => метод класса не может менять состояние экземпляра
# объекта (нет доступа к параметру self).
# Методы класса модифицируют состояние класса, которое
# применимо во всехэкземплярах класса.

# Статические методы - Static methods
# В нём нет ни self ни cls
# => не может модифицировать ни состояние объекта
# (экземпляра) ни состояние класса.
# Статические методы - средство организации пространства
# имен методов.

# Метод экземпляра (instance method):
obj = MyClass()
print(obj.method())
# ('вызван метод экземпляра', <__main__.MyClass object at 0x00000199004C5310>)
# Во время вызова Python заменяет self на объект экземп-
# ляра obj.
# Можно проигнорировать синтаксический сахар и передать
# экземпляр вручную:
print(MyClass.method(obj))  # тоже самое
# ('вызван метод экземпляра', <__main__.MyClass object at 0x00000199004C5310>)
# Методы экземпляра могут также получать ДОСТУП НЕПОСР-
# НО К САМОМУ КЛАССУ через атрубут self.__class__
# => методы экземпляра могут модифицировать как сост-е
# экземпляра, так и состояние в самом классе.

# Метод класса (class method):
print(obj.classmethod())
# ('вызван метод класса', <class '__main__.MyClass'>)
# Python автоматически передаёт класс объекта, в кач-ве
# первого аргумента cls в ф-ции.
# Такое поведение запускается через ТОЧЕЧНЫЙ СИНТАКСИС
# (dot syntax). Параметр self в методах экземпляра рабо-
# тает таким же образом.

# Обозначение параметров self и cls явл-ся согласованным
# правилом именования.
# Важно лишь, что в списке парамтеров они РАСПОЛАГАЮТСЯ
# ПЕРВЫМИ.

# Статический метод (static method)
print(obj.staticmethod())  # вызван статический метод
# Статический метод можно вызвать на экземпляре объекта
# За кадром ограничение доступа - не передаются арг-ты
# self и cls.
# => Статические методы не могут получить доступ к сост.
# класса или объекта.

# Вызов этих 3 методов без создания экземпляра обхекта:
print(MyClass.classmethod())
# ('вызван метод класса', <class '__main__.MyClass'>)
print(MyClass.staticmethod())
# вызван статический метод
# >>> MyClass.method()
# TypeError: """unbound method method() must
# be called with MyClass instance as first
# argument (got nothing instead)"""

class Pizza:
    def __init__(self, ingredients):
        self.ingredients = ingredients

    def __repr__(self):
        return f'Pizza({self.ingredients!r})'

print(Pizza(['помидоры', 'сыр']))
# Pizza(['помидоры', 'сыр'])

# Создадим более оптимальный интерфейс для созд-я
# объектов.
# => Используем МЕТОДЫ КЛАССА в кач-ве ФАБРИЧНЫХ Ф-ЦИЙ
# для удобного и быстрого фабричного создания
# различных пицц.
class Pizza:
    def __init__(self, ingredients):
        self.ingredients = ingredients
    def __repr__(self):
        return f'Pizza({self.ingredients!r})'

    @classmethod
    def margherita(cls):
        return cls(['моцарелла', 'помидоры'])

    @classmethod
    def prosciutto(cls):
        return cls(['моцарелла', 'помидоры', 'ветчина'])

# Грамотное использование cls вместо Pizza, если мы
# когда-то переименнуюем класс всё продолжит работать.
print(Pizza.margherita())
# Pizza(['моцарелла', 'помидоры'])
print(Pizza.prosciutto())
# Pizza(['моцарелла', 'помидоры', 'ветчина'])

# МЕТОДЫ КЛАССА позволяют определять для своих классов
# альтернативные конструкторы.

# ИСПОЛЬЗОВАНИЕ СТАТИЧЕСКИХ МЕТОДОВ. (c.149)
import math
class Pizza:
    def __init__(self, radius, ingredients):
        self.radius = radius
        self.ingredients = ingredients

    def __repr__(self):
        return (f'Pizza({self.radius!r}, '
                f'{self.ingredients!r})')

    def area(self):
        return self.circle_area(self.radius)

    @staticmethod
    def circle_area(r):
        return r ** 2 * math.pi

# Вычисление площади вынесено в отдельный статический
# метод circle_area(), который, т.к. статический, никак
# не может модифицировать экземпляр или сам класс.
# Что помогает четче представить составные части
# программы (что для чего исп-ся и что должно менять).
p = Pizza(4, ['mozzarella', 'tomatoes'])
print(p)  # Pizza(4, ['mozzarella', 'tomatoes'])
print(p.area())  # 50.26548245743669
print(Pizza.circle_area(4))  # 50.26548245743669

#--------------------------------------------------------
# 5. ОБЩИЕ СТРУКТУРЫ ДАННЫХ PYTHON. (с.153)

# АТД - Абстрактные Типы данных.
# Стивен С. Скиена «Алгоритмы: построение и анализ»
# (Steven S. Skiena’s, The Algorithm Design Manual).

# 5.1. СЛОВАРИ, АССОЦИАТИВНЫЕ МАССИВЫ И ХЕШ-ТАБЛИЦЫ.

# А) Словари - центральная фигура данных.
#    - Произвольное число объектов;
#    - каждый объект идентифицируется КЛЮЧОМ.

#    1. Ассоциативные массивы (associative arrays)
#    2. Ассоциативные хеш-таблицы (hashmaps)
#    3. Поисковые таблицы (lookup tables)
#    4. Таблицы преобразования

# "+" : эффективный поиск, вставка, удаление любого
#       объекта по ключу.

# СЛОВАРЬ dict() или {}, конструкции включения.
# Эта реализация встроена в ядро языка Python.
# КЛЮЧИ ДОЛЖНЫ ИМЕТЬ ХЕШИРУЕМЫЙ ТИП.

# Примеры создания словаря dict:
phonebook = {
    'боб' : 7387,
    'элис' : 3719,
    'джек' : 7052,
}
print(phonebook)
# {'боб': 7387, 'элис': 3719, 'джек': 7052}

squares = {x: x * x for x in range(6)}  # Констр-я вкл-я
print(squares)
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# (Хешируемый объект имеет хеш-значение, которое никогда
# не меняется в течение его жизни (__hash__), и его мож-
# но сравнивать с другими хеш-значениями (объектами)
# (__eq__).
# Эквивалентные друг другу хешируемые объекты должны
# иметь одинаковое хеш-значение.

# Неизменяемые типы: строковые значения, числа - хеши-
# руемые объекты => хорошо работают в кач-ве ключей сло-
# варей.
# Также можно исп-ть объекты-кортежи при условии, что
# они сами содержат только хешируемые типы.

# dict - РЕАЛИЗАЦИЯ ХЕШ-ТАБЛИЦА.
# Временная сложность = O(1) для поиска, вставки, обнов-
# ления, удаления (в среднем сл-е).

# Также для удобства стандартная библиотека Python
# содержит ряд специализированных словарей, на основе
# dict => та же временная сложность O(1).

# collections.OrderedDict - ПОМНИТ ПОРЯДОК ВСТАВКИ КЛЮЧЕЙ.
# Подкласс dict.
# Не явл-ся встроенной составной частью базового языка
# => должен быть импортирован из модуля collections из
# стандартной библиотеки.
import collections
d = collections.OrderedDict(one=1, two=2, three=3)
print(d)
# OrderedDict([('one', 1), ('two', 2), ('three', 3)])
d['четыре'] = 4  # d[key] = value
print(d)
# OrderedDict([('one', 1), ('two', 2), ('three', 3), ('четыре', 4)])
print(d.keys())
# odict_keys(['one', 'two', 'three', 'четыре'])

# collections.defaultdict - ВОЗВРАЩАЕТ ЗНАЧЕНИЯ, ЗАДАН-
# НЫЕ ПО УМОЛЧАНИЮ ДЛЯ ОТСУТСТВУЮЩИХ КЛЮЧЕЙ.
# defaultdict - подкласс dict
# В конструкторе принимает вызываемый объект, возвра-
# щаемое значение которого будет использовано, если тре-
# буемый ключ нельзя найти.

# Замена get() или отлавливания искл-я KeyError в
# обычных словарях.
from collections import defaultdict
dd = defaultdict(list)
# Попытка доступа к отс. ключу ЕГО СОЗДАЕТ И ИНИЦИАЛИЗИ-
# РУЕТ, исп-я принятую по умолчанию фабрику, то есть в
# данном примере list():
dd['собаки'].append('Руфус')
dd['собаки'].append('Кэтрин')
dd['собаки'].append('Сниф')
print(dd['собаки'])
# ['Руфус', 'Кэтрин', 'Сниф']
print(dd)
# defaultdict(<class 'list'>, {'собаки': ['Руфус', 'Кэтрин', 'Сниф']})

# collections.ChainMap - ПРОИЗВОДИТ ПОИСК В МНОГОЧИСЛЕН-
# НЫХ СЛОВАРЯХ КАК В ОДНОЙ ТАБЛИЦЕ СООТВЕТСТВИЯ.

# Поиск проводится ПО ОЧЕРЕДИ во всех базовых ассоц-х
# объектах до тех пор, пока ключ не будет найден.
# Вставка, обновление, удаление затрагивает ТОЛЬКО ПЕР-
# ВУЮ таблицу соответствия, добавленную в цепочку.
from collections import ChainMap
dict1 = {'один' : 1, 'два' : 2}
dict2 = {'три' : 3, 'четыре' : 4}
chain = ChainMap(dict1, dict2)
print(chain)
# ChainMap({'один': 1, 'два': 2}, {'три': 3, 'четыре': 4})

# ChainMap выполняет поиск в каждой коллекции в цепочке
# слева направо, пока не найдет ключ (или не потерпит
# неудачу):

